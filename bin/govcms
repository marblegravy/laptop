#!/usr/bin/env sh

[[ -d ~/.config ]] && CONFIG_FILE=~/.config/govcms || CONFIG_FILE=~/.govcms
CONFIG_OVERRIDDEN=0


function error_dir_exists	{ echo "Directory $DIRECTORY already exists."			>&2; exit 2; }
function error_no_group 	{ echo "GovCMS GitLab group not set. Please edit $CONFIG_FILE." >&2; exit 2; }
function error_no_repository	{ usage 							>&2; exit 2; }

function usage
{
	B="$(tput bold)"			# Executable/function name
	R="$(tput bold)$(tput setaf 1)" 	# Repository argument
	D="$(tput bold)$(tput setaf 2)" 	# Directory argument
	P="$(tput bold)$(tput setaf 5)" 	# Domain Prefix argument
	N="$(tput bold)$(tput setaf 4)" 	# Branch component
	C="$(tput sgr0)"			# Clear all text attributes

	BN0=$(basename "$0")

	[[ $CONFIG_OVERRIDDEN -gt 0 ]] && CFG=", ${R}overridden${C}" || CFG=""

	cat <<-END_OUT
		Usage: ${B}${BN0}${C} <${R}project${C}[:${N}branch${C}]> [${P}domain-prefix${C}] [${D}directory${C}]
		Downloads and initialises a GovCMS GitLab repository for development.

		Examples:
		${B}${BN0}${C} ${R}sitename${C}
		Clones $GITLAB_DOMAIN:/$GITLAB_GROUP/${R}sitename${C}.git to directory ./${R}sitename${C}, and domain https://${R}sitename${C}.docker.amazee.io.

		${B}${BN0}${C} ${R}sitename${C} ${D}site${C}
		Clones $GITLAB_DOMAIN:/$GITLAB_GROUP/${R}sitename${C}.git to directory ./${D}site${C}, and domain https://${D}site${C}.docker.amazee.io.

		${B}${BN0}${C} ${R}sitename${C} ${P}my-site${C} ${D}site-dir${C}
		Clones $GITLAB_DOMAIN:/$GITLAB_GROUP/${R}sitename${C}.git to directory ./${D}site-dir${C}, and domain https://${P}my-site${C}.docker.amazee.io.

		${B}${BN0}${C} ${R}sitename${C}:${N}my-branch${C}
		${B}${BN0}${C} ${R}sitename${C}:${N}my-branch${C} ${D}site${C}
		${B}${BN0}${C} ${R}sitename${C}:${N}my-branch${C} ${P}my-site${C} ${D}site-dir${C}
		As above, but checks out ${N}my-branch${C} instead of master. If ${N}my-branch${C} does not exist, it is created.

		${B}${BN0}${C} ${D}existing_dir${C}
		If ./${D}existing_dir${C} is a git repository, pulls from origin and rebuilds the project; otherwise prints an error and exits.

		${B}${BN0}${C}
		If current working directory is a git repository, pulls from origin and rebuilds the project; otherwise prints this help text and exits.

		${B}${BN0}${C} -h
		${B}${BN0}${C} --help
		Prints this help text and exits.

		Configuration (${B}${CONFIG_FILE/$(eval echo ~)/~}${C})${CFG}:
		GITLAB_DOMAIN = $GITLAB_DOMAIN
		GITLAB_GROUP  = $GITLAB_GROUP
	END_OUT
}

function load_or_init_config
{
	CONFIG_DOMAIN=git@projects.govcms.gov.au
	CONFIG_GROUP=''

	if [[ ! -f $CONFIG_FILE ]]
	then
		READ_PROMPT="Your GovCMS GitLab server is assumed to be '$CONFIG_DOMAIN'. Press <enter> to keep it, or type a new one (e.g. an SSH alias): "
		read -p "${READ_PROMPT}" INPUT_DOMAIN

		while [[ -z $CONFIG_GROUP ]]
		do
			READ_PROMPT="Please type the directory name of your GovCMS group, e.g. 'finance' or 'edu-paas': "
			read -p "${READ_PROMPT}" CONFIG_GROUP
		done

		cat > $CONFIG_FILE <<-END_CFG
			#!/usr/bin/env bash
			# GovCMS shell script configuration file.
			# The sha-bang is just to trigger syntax highlighting — this file is not intended for direct execution.

			GITLAB_DOMAIN='${INPUT_DOMAIN:-$CONFIG_DOMAIN}' # If you have a shorter alias set up in ~/.ssh/config, you can use it here
			GITLAB_GROUP='${CONFIG_GROUP}'
		END_CFG

		echo
		echo "Configuration file created at $CONFIG_FILE."
		echo
		echo
	fi

	source $CONFIG_FILE


	# Allow groups to be overridden by the command-line
	[[ -n $OVERRIDE_DOMAIN ]]	&& CONFIG_OVERRIDDEN=1	&& GITLAB_DOMAIN="$OVERRIDE_DOMAIN"
	[[ -n $OVERRIDE_GROUP ]]	&& CONFIG_OVERRIDDEN=1	&& GITLAB_GROUP="$OVERRIDE_GROUP"
}

function check_for_help_option
{
	for arg in $BASH_ARGV									# Dodgy, but we don't need full util-linux/getopts for this…
	do
		[[ $arg == '-h' || $arg == '--help' ]] && usage && exit 0
	done
}

function git_do_clone
{
	DO_CLONE=1										# Affects customise_environment function

	REMOTE="${GITLAB_DOMAIN}:${GITLAB_GROUP}/${REPOSITORY}.git"

	if [[ -n $(git ls-remote -hq "${REMOTE}" | grep $BRANCH) ]]				# If requested branch exists on remote…
	then											# …check it out directly…
		git clone	-b "${BRANCH}"	"${REMOTE}" "${DIRECTORY}" && cd "${DIRECTORY}" || exit 1
	else											# …else clone master and create a new branch locally.
		git clone			"${REMOTE}" "${DIRECTORY}" && cd "${DIRECTORY}" || exit 1
		git checkout	-b "${BRANCH}"
	fi
}

function customise_environment
{
	ENV_FILE=.env

	ENV_FIXES=()
	ENV_FIXES+=("s|^\(COMPOSE_PROJECT_NAME=\).*$|\1govcms-${PREFIX}|g")			# Set container names
	ENV_FIXES+=("s|^\(LOCALDEV_URL=\).*\(\.docker\.amazee\.io\)$|\1https://${PREFIX}\2|g")	# Set local development URL
	ENV_FIXES+=("s|^#[[:space:]]*\(MARIADB_DATA_IMAGE\)|\1|g")				# Always pull MariaDB image

	if [[ $(uname -s) == Darwin ]]
	then
		ENV_FIXES+=("s|^#[[:space:]]*\(VOLUME_FLAGS=cached\)|\1|g")			# Mac fix
	fi


	if [[ DO_CLONE -gt 0 ]]
	then
		git update-index --skip-worktree "${ENV_FILE}"

		for fix in "${ENV_FIXES[@]}"; do
			sed -e "$fix" -i '' "${ENV_FILE}"
		done
	fi
}

function force_start_pygmy
{
	[[ -n $(pygmy status | grep not) ]]	&& pygmy up
	read -p "Add alternate SSH key to Pygmy? ( n / SSH key name in ~/.ssh/: " input_pygkey
	case $input_pygkey in  
		n|N) echo no extra pyg keys added ;; 
		*) pygmy addkey /Users/$(whoami)/.ssh/$input_pygkey ;; 
	esac
}

function ahoy_command
{
	[[ -n $(ahoy --help | grep "$1") ]]			&& ahoy "$1"
}

function ahoy_there										# Re-up all the things
{
	if [[ -n $(ahoy --help | grep there) ]] 						# Probably a way to reuse ahoy_command for this…
	then
		ahoy		there
	else
		ahoy_command	get-composer
		rm	-f	composer.lock			> /dev/null
		composer	update
		ahoy_command	up
		ahoy_command	refresh-db
	fi
}


load_or_init_config
check_for_help_option


# Get command-line arguments
REPOSITORY="${1%%:*}"
PREFIX="${2:-$REPOSITORY}"
DIRECTORY="${3:-$PREFIX}"

BRANCH="${1//${REPOSITORY}}"
BRANCH="${BRANCH##:}"
BRANCH="${BRANCH:-master}"

DO_CLONE=0


# Validate options
[[ -z $GITLAB_GROUP ]]				&& error_no_group
[[ -z $REPOSITORY	&& ! -d .git ]] 	&& error_no_repository


# Repository
if [[ -d .git ]]										# Program was called from within a working git repository
then
	git pull
elif [[ -d "${DIRECTORY}/.git" ]]								# Specified directory already exists and is a git repository
then
	cd "${DIRECTORY}"
	git pull
elif [[ -d "${DIRECTORY}" ]]									# Specified directory already exists, but is NOT a git repository
then
	error_dir_exists
else												# FIRE EVERYTHING!!
	git_do_clone
fi


customise_environment
force_start_pygmy

ahoy_there

exit 0												# Allow chained execution, e.g. `govcms department && cd $_`
